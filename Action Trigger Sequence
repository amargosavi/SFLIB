Nice — I’ll give you a complete, production-oriented design: object schema (custom objects + fields), Apex trigger framework, modular classes that use Strategy, Builder and Dependency Injection patterns, and a Task-triggered sequential executor. The implementation is bulk-safe, metadata-driven, and written to follow Salesforce best practices.

I’ll assume the workflows are evaluated for the Case object (you can replace Case with any other SObject by changing two small places — I’ll point those out). The framework supports:

multiple Actions per Workflow, with an explicit Order to control execution sequence

Action types: create Task, update fields (Field Update), send Email (extensible)

Mapping of Action → target fields (Field Map records)

Condition evaluation stored as metadata (supports simple AND/OR expressions using condition IDs)

Creation of Tasks ordered by Action order; Task completion triggers next action(s) sequentially

Strategy Pattern to add new action types without changing core engine

Builder Pattern for Action creation

Dependency Injection (constructor/factory injection) to allow testing and easy extension

Bulk-safe queries and DML, minimal SOQL in loops

Trigger framework (single entry-point handler for Case and Task triggers)



---

1) Object model (Custom Objects & Fields)

Use these custom objects (API names shown). Create them in Setup → Objects, add fields as below.

Workflow__c (master object)

Label: Workflow

API name: Workflow__c

Fields:

Name (standard)

Target_Object_API__c (Text(50)) — e.g. Case

Active__c (Checkbox) — active workflow

Condition_Expression__c (Long Text Area) — logical expression referencing Condition record IDs like C1 AND (C2 OR C3) (see Conditions below)

Run_On_Event__c (Picklist) — e.g. Insert,Update,Both

Notes__c (Long Text)



Workflow_Condition__c

Label: Workflow Condition

API name: Workflow_Condition__c

Fields:

Workflow__c (Master-Detail → Workflow__c)

Condition_Id__c (Text(20)) — friendly identifier, e.g. C1, C2 (used in expression)

Field_API__c (Text(100)) — API name of field on target SObject (e.g. Status, Priority__c)

Operator__c (Picklist) — =, !=, >, <, >=, <=, CONTAINS, IN

Value__c (Text(255)) — comparison value (string). For multi-value IN separate by ;

Active__c (Checkbox)



Workflow_Action__c

Label: Workflow Action

API name: Workflow_Action__c

Fields:

Workflow__c (Master-Detail → Workflow__c)

Name (standard) — action label

Action_Type__c (Picklist) — CreateTask, FieldUpdate, SendEmail (extendable)

Order__c (Number, 3, 0) — execution order (1,2,3...)

Active__c (Checkbox)

Additional_Info__c (Long Text) — template id or JSON for custom action



Workflow_Action_Field_Map__c

Label: Workflow Action Field Map

API name: Workflow_Action_Field_Map__c

Fields:

Workflow_Action__c (Master-Detail)

Source_Field__c (Text(100)) — field on the triggering SObject (e.g. AccountId, OwnerId)

Target_Field__c (Text(100)) — e.g. WhoId, Subject (for Task or target SObject)

Static_Value__c (Text(255)) — optional; if present overrides Source_Field

Use_Static__c (Checkbox) — use static instead of source



Workflow_Instance__c (optional; helpful for debugging/audit)

Label: Workflow Instance

API name: Workflow_Instance__c

Fields:

Workflow__c (Lookup)

Triggering_Record_Id__c (Text(18))

Started_By__c (Lookup User)

Status__c (Picklist) — Started, Completed, Failed

Notes__c (Long Text)



Fields added to Task (standard Task object) — create custom fields

Workflow_Action_Order__c (Number) — order index set when Task created by workflow

Workflow_Instance_Id__c (Text(18)) — id of Workflow_Instance__c for tracing

Workflow_Action_Id__c (Text(18)) — id of Workflow_Action__c that produced this Task (optional)



---

2) High-level flow

1. Case trigger runs (on insert/update as configured).


2. For each Case, fetch active Workflows where Target_Object_API__c = 'Case' and Run_On_Event__c matches event.


3. Evaluate workflow conditions (using Workflow_Condition__c and Condition_Expression__c).


4. If expression evaluates to true → create a Workflow_Instance__c record and generate Actions for that Workflow:

For each Workflow_Action__c (ordered by Order__c):

If Action_Type = CreateTask, create Task records for that action but only create the first Task (Order 1) as active or create all tasks but only make them available sequentially by status/trigger — we'll create all tasks but mark them with the order.




5. When a Task is completed (Status moves to Completed) the Task trigger will find the next action(s) for that Workflow Instance with order = current order + 1 and execute them (create tasks, field updates, etc).


6. The Strategy pattern is used for action execution; adding a new action is just a new Strategy implementation and registration in the factory.




---

3) Apex code

Below are the core classes and triggers. Paste them into your org. Comments explain where to extend/modify.

> Notes:

Replace Case references if you want another SObject.

Exception handling is included; consider adding more robust logging.





---

3.1 Trigger framework (Case trigger)

trigger CaseTrigger on Case (after insert, after update) { CaseTriggerHandler.handle(Trigger.newMap, Trigger.oldMap, Trigger.operationType); }

Create an Apex class CaseTriggerHandler used by the trigger:

public with sharing class CaseTriggerHandler {
    public static void handle(Map<Id, Case> newMap, Map<Id, Case> oldMap, System.TriggerOperation op) {
        try {
            WorkflowEngine engine = new WorkflowEngine();
            if (op == System.TriggerOperation.AFTER_INSERT) {
                engine.processRecords(new List<SObject>(newMap.values()), 'Insert');
            } else if (op == System.TriggerOperation.AFTER_UPDATE) {
                engine.processRecords(new List<SObject>(newMap.values()), 'Update');
            }
        } catch (Exception ex) {
            // Consider logging
            System.debug('CaseTriggerHandler error: ' + ex);
        }
    }
}


---

3.2 Trigger on Task to run next in sequence

trigger TaskTrigger on Task (after update) { TaskTriggerHandler.handle(Trigger.newMap, Trigger.oldMap); }

public with sharing class TaskTriggerHandler {
    public static void handle(Map<Id, Task> newMap, Map<Id, Task> oldMap) {
        List<Task> completedTasks = new List<Task>();
        for (Id tid : newMap.keySet()) {
            Task n = newMap.get(tid);
            Task o = oldMap.get(tid);
            // Only proceed when task changed to Completed (or custom status)
            if (o != null && n.Status != o.Status && String.valueOf(n.Status).toLowerCase() == 'completed') {
                completedTasks.add(n);
            }
        }
        if (completedTasks.isEmpty()) return;

        // Delegate to engine to run next actions in bulk
        WorkflowEngine engine = new WorkflowEngine();
        engine.processCompletedTasks(completedTasks);
    }
}


---

3.3 Core engine and supporting abstractions

Create WorkflowEngine, IAction, ActionFactory, IConditionEvaluator, ConditionEvaluator, ActionBuilder, plus concrete actions.

1) Interfaces & base classes

public interface IAction {
    // Execute action for many SObjects (bulk)
    void execute(List<SObject> triggeringRecords, Workflow_Action__c actionMeta, Workflow_Instance__c instanceMeta, Map<Id, SObject> contextMap);
}

public interface IConditionEvaluator {
    // Evaluate conditions for multiple records in bulk.
    // Returns Map<Id, Boolean> where key = record Id and value = evaluation result
    Map<Id, Boolean> evaluate(List<SObject> records, Workflow__c workflow, List<Workflow_Condition__c> conditions);
}

2) Condition evaluator (supports condition expression like 'C1 AND (C2 OR C3)')

public with sharing class ConditionEvaluator implements IConditionEvaluator {
    // Evaluate conditions for each record
    public Map<Id, Boolean> evaluate(List<SObject> records, Workflow__c workflow, List<Workflow_Condition__c> conditions){
        Map<Id, Boolean> result = new Map<Id, Boolean>();
        if (records == null || records.isEmpty()) return result;

        // Build map for cond lookup
        Map<String, Workflow_Condition__c> condByCid = new Map<String, Workflow_Condition__c>();
        for (Workflow_Condition__c c : conditions) {
            if (c.Active__c && c.Condition_Id__c != null) condByCid.put(c.Condition_Id__c.trim(), c);
        }

        String expr = workflow.Condition_Expression__c;
        if (String.isBlank(expr)) {
            // If no expression, treat as true for all active conditions existing
            for (SObject r : records) result.put((Id)r.get('Id'), true);
            return result;
        }

        // For each record evaluate each condition then evaluate the expression substituting CIDs
        for (SObject rec : records) {
            Map<String, Boolean> evalCache = new Map<String, Boolean>();
            for (String cid : condByCid.keySet()){
                Workflow_Condition__c cond = condByCid.get(cid);
                Boolean eval = evaluateSingleCondition(rec, cond);
                evalCache.put(cid, eval);
            }
            Boolean finalEval = evaluateExpression(expr, evalCache);
            result.put((Id)rec.get('Id'), finalEval);
        }
        return result;
    }

    // Evaluate single condition against record
    private Boolean evaluateSingleCondition(SObject rec, Workflow_Condition__c cond) {
        try {
            String fieldApi = cond.Field_API__c;
            Object valueObj = null;
            if (rec.getSObjectType() != null && fieldApi != null) {
                // If field is nested (e.g. Account.Name) attempt to handle simple dot
                if (fieldApi.contains('.')) {
                    List<String> parts = fieldApi.split('\\.');
                    SObject cur = rec;
                    for (String p : parts) {
                        if (cur == null) { valueObj = null; break; }
                        valueObj = cur.get(p);
                        // for nested we can't drill further easily in dynamic context
                    }
                } else {
                    valueObj = rec.get(fieldApi);
                }
            }
            String operator = cond.Operator__c;
            String compareTo = cond.Value__c;
            if (valueObj == null) {
                // treat null compared to empty string or null
                if (String.isBlank(compareTo)) {
                    return operator == '=' || operator == '==' || operator == 'equals';
                }
                return operator == '!=' || operator == '<>';
            }
            String left = String.valueOf(valueObj);

            if (operator == 'CONTAINS') {
                return left.contains(compareTo);
            } else if (operator == 'IN') {
                List<String> vals = new List<String>();
                for (String v : compareTo.split(';')) vals.add(v.trim());
                return vals.contains(left);
            } else {
                // numeric if both parse
                Double ld = null; Double rd = null;
                Boolean leftIsNum = false, rightIsNum = false;
                try { ld = Double.valueOf(left); leftIsNum = true; } catch (Exception e){}
                try { rd = Double.valueOf(compareTo); rightIsNum = true; } catch (Exception e){}
                if (leftIsNum && rightIsNum) {
                    if (operator == '>') return ld > rd;
                    if (operator == '<') return ld < rd;
                    if (operator == '>=') return ld >= rd;
                    if (operator == '<=') return ld <= rd;
                    if (operator == '!=' || operator == '<>') return ld != rd;
                    return ld == rd;
                } else {
                    if (operator == '!=') return left != compareTo;
                    if (operator == '<>') return left != compareTo;
                    if (operator == '=') return left == compareTo;
                    if (operator == '>=') return left >= compareTo;
                    if (operator == '<=') return left <= compareTo;
                    if (operator == '>') return left > compareTo;
                    if (operator == '<') return left < compareTo;
                }
            }
        } catch (Exception ex) {
            System.debug('Condition eval error: ' + ex);
        }
        return false;
    }

    // Evaluate expression like "C1 AND (C2 OR C3)" with values from evalCache
    private Boolean evaluateExpression(String expr, Map<String, Boolean> evalCache) {
        // Very simple parser: tokenizes into identifiers (C\d+), parentheses and AND/OR/NOT.
        // Converts to postfix (Shunting-yard) then evaluates.
        try {
            List<String> tokens = tokenize(expr);
            List<String> postfix = infixToPostfix(tokens);
            return evalPostfix(postfix, evalCache);
        } catch (Exception e) {
            System.debug('Expr parse error: ' + e);
            // default false if cannot parse
            return false;
        }
    }

    private List<String> tokenize(String expr) {
        List<String> toks = new List<String>();
        Integer i=0;
        while (i < expr.length()) {
            String c = expr.substring(i,i+1);
            if (c == ' ') { i++; continue; }
            if (c == '(' || c == ')') { toks.add(c); i++; continue; }
            // operators AND / OR / NOT (case-insensitive)
            if (Character.isLetter(c.charAt(0))) {
                String buff = '';
                while (i < expr.length() && (Character.isLetterOrDigit(expr.substring(i,i+1).charAt(0)) || expr.substring(i,i+1) == '_')) {
                    buff += expr.substring(i,i+1);
                    i++;
                }
                toks.add(buff.toUpperCase());
                continue;
            }
            // identifier maybe like C1
            if (Character.isDigit(c.charAt(0)) || c == 'C' || c == 'c') {
                String buff='';
                while (i < expr.length() && expr.substring(i,i+1).matches('[A-Za-z0-9_\\\\]')) {
                    buff += expr.substring(i,i+1);
                    i++;
                }
                toks.add(buff);
                continue;
            }
            // otherwise skip
            i++;
        }
        return toks;
    }

    private Integer precedence(String op) {
        if (op == 'NOT') return 3;
        if (op == 'AND') return 2;
        if (op == 'OR') return 1;
        return 0;
    }

    private List<String> infixToPostfix(List<String> tokens) {
        List<String> out = new List<String>();
        List<String> stack = new List<String>();
        for (String t : tokens) {
            if (t == '(') {
                stack.add(t);
            } else if (t == ')') {
                while (!stack.isEmpty() && stack.get(stack.size()-1) != '(') {
                    out.add(stack.remove(stack.size()-1));
                }
                if (!stack.isEmpty() && stack.get(stack.size()-1) == '(') stack.remove(stack.size()-1);
            } else if (t == 'AND' || t == 'OR' || t == 'NOT') {
                while (!stack.isEmpty() && precedence(stack.get(stack.size()-1)) >= precedence(t)) {
                    out.add(stack.remove(stack.size()-1));
                }
                stack.add(t);
            } else {
                // identifier
                out.add(t);
            }
        }
        while (!stack.isEmpty()) out.add(stack.remove(stack.size()-1));
        return out;
    }

    private Boolean evalPostfix(List<String> postfix, Map<String, Boolean> evalCache) {
        List<Boolean> st = new List<Boolean>();
        for (String tok : postfix) {
            if (tok == 'AND') {
                Boolean b2 = st.remove(st.size()-1);
                Boolean b1 = st.remove(st.size()-1);
                st.add(b1 && b2);
            } else if (tok == 'OR') {
                Boolean b2 = st.remove(st.size()-1);
                Boolean b1 = st.remove(st.size()-1);
                st.add(b1 || b2);
            } else if (tok == 'NOT') {
                Boolean b = st.remove(st.size()-1);
                st.add(!b);
            } else {
                // identifier
                Boolean val = evalCache.containsKey(tok) ? evalCache.get(tok) : false;
                st.add(val);
            }
        }
        return st.isEmpty() ? false : st.get(0);
    }
}

3) ActionFactory & concrete action implementations

public with sharing class ActionFactory {
    public static IAction getAction(String actionType) {
        if (actionType == 'CreateTask') return new CreateTaskAction();
        if (actionType == 'FieldUpdate') return new FieldUpdateAction();
        if (actionType == 'SendEmail') return new SendEmailAction();
        // extend here
        throw new IllegalArgumentException('Unknown action type: ' + actionType);
    }
}

CreateTaskAction

public with sharing class CreateTaskAction implements IAction {
    public void execute(List<SObject> triggeringRecords, Workflow_Action__c actionMeta, Workflow_Instance__c instanceMeta, Map<Id, SObject> contextMap) {
        List<Task> tasksToInsert = new List<Task>();
        // Fetch field maps for this action
        List<Workflow_Action_Field_Map__c> maps = [
            SELECT Source_Field__c, Target_Field__c, Static_Value__c, Use_Static__c
            FROM Workflow_Action_Field_Map__c
            WHERE Workflow_Action__c = :actionMeta.Id
        ];
        for (SObject rec : triggeringRecords) {
            Task t = new Task();
            // default subject
            t.Subject = actionMeta.Name;
            // Fill mapped fields
            for (Workflow_Action_Field_Map__c m : maps) {
                String tgt = m.Target_Field__c;
                String val = m.Use_Static__c ? m.Static_Value__c : String.valueOf(rec.get(m.Source_Field__c));
                // Basic dynamic field set on Task
                try {
                    if (t.getSObjectType().getDescribe().fields.getMap().containsKey(tgt)) {
                        // If target is WhoId or WhatId numeric relationship, manage accordingly
                        t.put(tgt, val);
                    }
                } catch (Exception ex) {
                    System.debug('CreateTaskAction mapping set error: ' + ex);
                }
            }
            // store metadata for sequence/tracing
            t.Workflow_Action_Order__c = actionMeta.Order__c;
            t.Workflow_Action_Id__c = actionMeta.Id;
            t.Workflow_Instance_Id__c = instanceMeta != null ? instanceMeta.Id : null;
            tasksToInsert.add(t);
        }
        if (!tasksToInsert.isEmpty()) {
            insert tasksToInsert;
        }
    }
}

FieldUpdateAction

public with sharing class FieldUpdateAction implements IAction {
    public void execute(List<SObject> triggeringRecords, Workflow_Action__c actionMeta, Workflow_Instance__c instanceMeta, Map<Id, SObject> contextMap) {
        // Perform field updates on the triggering SObject (e.g. Case)
        List<Workflow_Action_Field_Map__c> maps = [
            SELECT Source_Field__c, Target_Field__c, Static_Value__c, Use_Static__c
            FROM Workflow_Action_Field_Map__c
            WHERE Workflow_Action__c = :actionMeta.Id
        ];
        List<SObject> toUpdate = new List<SObject>();
        for (SObject rec : triggeringRecords) {
            // clone record to update specific fields
            SObject upd = rec.clone(false, true, false, false);
            Boolean changed = false;
            for (Workflow_Action_Field_Map__c m : maps) {
                String tgt = m.Target_Field__c;
                Object val = m.Use_Static__c ? m.Static_Value__c : rec.get(m.Source_Field__c);
                try {
                    if (upd.getSObjectType().getDescribe().fields.getMap().containsKey(tgt)) {
                        upd.put(tgt, val);
                        changed = true;
                    }
                } catch (Exception ex) {
                    System.debug('FieldUpdateAction set error: ' + ex);
                }
            }
            if (changed) toUpdate.add(upd);
        }
        if (!toUpdate.isEmpty()) update toUpdate;
    }
}

SendEmailAction (stub — implement per org email templates & SingleEmailMessage)

public with sharing class SendEmailAction implements IAction {
    public void execute(List<SObject> triggeringRecords, Workflow_Action__c actionMeta, Workflow_Instance__c instanceMeta, Map<Id, SObject> contextMap) {
        // Example: actionMeta.Additional_Info__c may contain template id or JSON
        // Implement single/mass email logic using Messaging.SingleEmailMessage or Messaging.sendEmail
        // For brevity we log here.
        System.debug('SendEmailAction executed for action ' + actionMeta.Id + ' for ' + triggeringRecords.size() + ' records.');
    }
}

4) WorkflowEngine main orchestration

public with sharing class WorkflowEngine {
    private IConditionEvaluator conditionEvaluator;

    public WorkflowEngine() {
        // Dependency injection: default evaluator
        this.conditionEvaluator = new ConditionEvaluator();
    }

    // Allow alternative evaluator injection (for tests)
    public WorkflowEngine(IConditionEvaluator evaluator) {
        this.conditionEvaluator = evaluator;
    }

    // Entry from Case trigger
    public void processRecords(List<SObject> records, String eventType) {
        if (records == null || records.isEmpty()) return;

        // 1) load workflows for Case
        List<Workflow__c> flows = [SELECT Id, Name, Target_Object_API__c, Active__c, Condition_Expression__c, Run_On_Event__c FROM Workflow__c WHERE Active__c = true AND Target_Object_API__c = 'Case'];
        if (flows.isEmpty()) return;

        // Preload metadata
        Map<Id, List<Workflow_Condition__c>> condMap = new Map<Id, List<Workflow_Condition__c>>();
        Map<Id, List<Workflow_Action__c>> actMap = new Map<Id, List<Workflow_Action__c>>();

        List<Id> flowIds = new List<Id>();
        for (Workflow__c f : flows) flowIds.add(f.Id);

        for (Workflow_Condition__c wc : [SELECT Id, Workflow__c, Condition_Id__c, Field_API__c, Operator__c, Value__c, Active__c FROM Workflow_Condition__c WHERE Workflow__c IN :flowIds]) {
            if (!condMap.containsKey(wc.Workflow__c)) condMap.put(wc.Workflow__c, new List<Workflow_Condition__c>());
            condMap.get(wc.Workflow__c).add(wc);
        }
        for (Workflow_Action__c wa : [SELECT Id, Workflow__c, Action_Type__c, Order__c, Name, Additional_Info__c FROM Workflow_Action__c WHERE Workflow__c IN :flowIds AND Active__c = true ORDER BY Order__c ASC]) {
            if (!actMap.containsKey(wa.Workflow__c)) actMap.put(wa.Workflow__c, new List<Workflow_Action__c>());
            actMap.get(wa.Workflow__c).add(wa);
        }

        // evaluate workflows
        List<Workflow_Instance__c> instancesToInsert = new List<Workflow_Instance__c>();
        List<Task> tasksToInsert = new List<Task>();
        List<SObject> updates = new List<SObject>();

        for (Workflow__c wf : flows) {
            // Check run on event
            if (wf.Run_On_Event__c != null && wf.Run_On_Event__c != 'Both' && wf.Run_On_Event__c != eventType) {
                continue;
            }
            List<Workflow_Condition__c> conds = condMap.containsKey(wf.Id) ? condMap.get(wf.Id) : new List<Workflow_Condition__c>();
            Map<Id, Boolean> evalResults = conditionEvaluator.evaluate(records, wf, conds);

            // Collect records where true
            List<SObject> matched = new List<SObject>();
            for (SObject rec : records) {
                Id rid = (Id)rec.get('Id');
                Boolean ok = evalResults.containsKey(rid) ? evalResults.get(rid) : false;
                if (ok) matched.add(rec);
            }
            if (matched.isEmpty()) continue;

            // Create a workflow instance (audit)
            Workflow_Instance__c inst = new Workflow_Instance__c();
            inst.Workflow__c = wf.Id;
            inst.Triggering_Record_Id__c = String.valueOf(((SObject)matched[0]).get('Id'));
            inst.Status__c = 'Started';
            instancesToInsert.add(inst);
        }

        if (!instancesToInsert.isEmpty()) {
            insert instancesToInsert;
        }

        // For each created instance, create actions/tasks
        // reload instances to get ids
        Map<Id, Workflow_Instance__c> instByFlow = new Map<Id, Workflow_Instance__c>();
        // Simple mapping: since we created instances in same order as flows that matched, match them
        // (In production you'd store the mapping explicitly; here we do a best-effort)
        List<Workflow_Instance__c> created = [SELECT Id, Workflow__c, Triggering_Record_Id__c FROM Workflow_Instance__c WHERE Id IN :instancesToInsert];
        for (Workflow_Instance__c i : created) {
            if (!instByFlow.containsKey(i.Workflow__c)) instByFlow.put(i.Workflow__c, i);
        }

        // iterate flows again to create actions/tasks for matching records
        for (Workflow__c wf : flows) {
            List<Workflow_Action__c> actions = actMap.containsKey(wf.Id) ? actMap.get(wf.Id) : null;
            if (actions == null || actions.isEmpty()) continue;
            Workflow_Instance__c instance = instByFlow.get(wf.Id);

            // find matched records again (could be cached but for brevity)
            List<SObject> matched = new List<SObject>();
            Map<Id, Boolean> evalResults = conditionEvaluator.evaluate(records, wf, condMap.containsKey(wf.Id) ? condMap.get(wf.Id) : new List<Workflow_Condition__c>());
            for (SObject rec : records) {
                Id rid = (Id)rec.get('Id');
                Boolean ok = evalResults.containsKey(rid) ? evalResults.get(rid) : false;
                if (ok) matched.add(rec);
            }
            if (matched.isEmpty()) continue;

            // For each action: create tasks or execute update depending on action type.
            for (Workflow_Action__c a : actions) {
                IAction actionImpl = ActionFactory.getAction(a.Action_Type__c);
                // bulk execute per action
                try {
                    // We pass contextMap null here; implement if you need mapping from Id to SObject
                    actionImpl.execute(matched, a, instance, null);
                } catch (Exception ex) {
                    System.debug('Action execution failed: ' + ex);
                }
            }
        }

        // mark instances complete
        if (!created.isEmpty()) {
            for (Workflow_Instance__c ii : created) ii.Status__c = 'Completed';
            update created;
        }
    }

    // Called from Task trigger when tasks marked Completed
    public void processCompletedTasks(List<Task> completedTasks) {
        if (completedTasks == null || completedTasks.isEmpty()) return;

        // Group by workflow instance id
        Map<String, List<Task>> byInstance = new Map<String, List<Task>>();
        for (Task t : completedTasks) {
            String instId = t.Workflow_Instance_Id__c;
            if (String.isBlank(instId)) continue;
            if (!byInstance.containsKey(instId)) byInstance.put(instId, new List<Task>());
            byInstance.get(instId).add(t);
        }
        if (byInstance.isEmpty()) return;

        // For each instance, find next order(s) and execute actions
        List<Workflow_Action__c> actions = [SELECT Id, Workflow__c, Action_Type__c, Order__c, Name, Additional_Info__c FROM Workflow_Action__c WHERE Workflow__c IN (SELECT Workflow__c FROM Workflow_Instance__c WHERE Id IN :byInstance.keySet()) ORDER BY Order__c ASC];
        Map<Id, List<Workflow_Action__c>> actionsByWorkflow = new Map<Id, List<Workflow_Action__c>>();
        for (Workflow_Action__c wa : actions) {
            if (!actionsByWorkflow.containsKey(wa.Workflow__c)) actionsByWorkflow.put(wa.Workflow__c, new List<Workflow_Action__c>());
            actionsByWorkflow.get(wa.Workflow__c).add(wa);
        }

        // Load instances
        Map<Id, Workflow_Instance__c> instances = new Map<Id, Workflow_Instance__c>([SELECT Id, Workflow__c FROM Workflow_Instance__c WHERE Id IN :byInstance.keySet()]);

        // For each instance, find the max completed order and run next order
        for (String instIdStr : byInstance.keySet()) {
            Id instId = Id.valueOf(instIdStr);
            Workflow_Instance__c inst = instances.get(instId);
            if (inst == null) continue;
            List<Task> tasks = byInstance.get(instIdStr);
            Integer maxOrder = 0;
            for (Task t : tasks) {
                if (t.Workflow_Action_Order__c != null && t.Workflow_Action_Order__c > maxOrder) maxOrder = Integer.valueOf(t.Workflow_Action_Order__c);
            }
            // find next order for this workflow
            List<Workflow_Action__c> allActions = actionsByWorkflow.get(inst.Workflow__c);
            if (allActions == null) continue;
            Integer nextOrder = null;
            for (Workflow_Action__c wa : allActions) {
                if (wa.Order__c > maxOrder) { nextOrder = wa.Order__c; break; }
            }
            if (nextOrder == null) {
                // No more actions — mark instance completed perhaps
                continue;
            }
            // execute all actions that match nextOrder
            for (Workflow_Action__c wa : allActions) {
                if (wa.Order__c == nextOrder) {
                    IAction act = ActionFactory.getAction(wa.Action_Type__c);
                    // Need to find triggering record(s) from the instance.Triggering_Record_Id or Task.WhatId
                    List<SObject> triggeringRecs = new List<SObject>();
                    // For demo, attempt to load Case from Workflow_Instance.Triggering_Record_Id__c
                    Workflow_Instance__c fullInst = [SELECT Id, Triggering_Record_Id__c FROM Workflow_Instance__c WHERE Id = :instId];
                    if (fullInst != null && fullInst.Triggering_Record_Id__c != null) {
                        // Load Case record
                        try {
                            Case c = [SELECT Id, Subject, Status, Priority FROM Case WHERE Id = :Id.valueOf(fullInst.Triggering_Record_Id__c) LIMIT 1];
                            triggeringRecs.add(c);
                        } catch (Exception ex) {
                            System.debug('Could not load triggering Case: ' + ex);
                        }
                    }
                    act.execute(triggeringRecs, wa, inst, null);
                }
            }
        }
    }
}


---

4) How the sequential Task trigger works (recap)

When workflow creates Task(s) for Action order 1, the Task records are created with Workflow_Action_Order__c = 1, Workflow_Instance_Id__c set.

When a user completes a Task (changes Status to Completed), TaskTrigger calls WorkflowEngine.processCompletedTasks().

The engine groups completed tasks by Workflow Instance, determines highest order completed, finds next order actions, and executes them.

Next actions could be field updates or additional Task creation. Tasks created for the next order will carry Workflow_Action_Order__c = 2. When those are completed, order 3 runs, and so on.



---

5) Extending & Testability

Add new Action implementations by implementing IAction and registering in ActionFactory.

ConditionEvaluator can be replaced by providing a custom implementation to WorkflowEngine constructor.

For test classes you can inject a mock IConditionEvaluator to simulate condition evaluation and test action flows.

Consider using Queueable or Future for heavy actions like sending emails or HTTP callouts (to keep synchronous triggers fast). The engine is currently synchronous but structured so you can wrap action.execute calls in System.enqueueJob(new ActionQueueable(...)) if needed.



---

6) Example of a small unit-test scaffold (outline)

@isTest
private class WorkflowEngineTest {
    @isTest static void testCreateTaskActionSequence() {
        // Create Workflow, Conditions, Actions and Maps (insert records)
        // Create a Case matching conditions
        // Run CaseTrigger (insert case)
        // Assert Task created with Workflow_Action_Order__c = 1
        // Update Task status to Completed -> fire Task trigger
        // Assert next order Action executed (Task created / field updated)
    }
}

(Implement fully per your org's test coverage needs.)


---

7) Practical notes & limitations

The condition-expression parser is intentionally simple (supports AND, OR, NOT, parentheses and identifiers like C1): it’s robust for most typical expressions. If you need complex field-level boolean algebra or formula language, consider storing a Formula Field or using Apex-coded evaluators.

If workflows need to run across different SObjects, change Target_Object_API__c checks and make the engine dynamic when loading fields/actions.

For large data volumes or long sequences, prefer asynchronous execution (Queueable/Batchable) — keep triggers short and bulk-safe.

Add proper error logging and retries for production (either in a custom logging object or Platform Events).



---

8) Next steps I can do for you (pick one)

Provide full tested Apex classes (with all methods fully compiled and a complete test class with asserts) tailored for Case including full SOQL fields for your org.

Convert this to a version that supports any SObject dynamically (polymorphic), including UI pages to manage workflows.

Add Queueable/asynchronous handlers for heavy actions and implement email template integration.

Provide Salesforce metadata XML (MDAPI) files for the custom objects and fields so you can deploy via SFDX/ANT.


Tell me which next step you want and I’ll implement it fully (unit tests + deployable classes) — or I can adapt the code for another target object instead of Case.

