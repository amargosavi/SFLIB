Excellent point üëå ‚Äî right now, we‚Äôve got conditions and actions mixed together in the same config object.
If you want true workflow behavior, we should separate them:


---

üîπ Refined Data Model

1. Workflow__c (the ‚Äúrule‚Äù itself)

Name

Object_API__c (e.g., Account)

Logic_Type__c (AND / OR)

Active__c (Checkbox)



2. WorkflowCondition__c (the conditions for the workflow)

Lookup to Workflow__c

Field_API__c

Operator__c (Equals, Not Equals, Greater, Less, Contains)

Value__c



3. WorkflowAction__c (the actions for the workflow)

Lookup to Workflow__c

Action_Type__c (FieldUpdate, Email, Task, API)

Action_Field__c

Action_Value__c

Email_Template_Id__c

Task_Subject__c, Task_Status__c

API_Type__c (Apex, REST)

API_Method__c

API_Payload__c





---

üîπ Apex Framework (Builder + Strategy + DI)

1. Workflow Rule Aggregate

public class WorkflowRule {
    public Workflow__c workflow { get; set; }
    public List<WorkflowCondition__c> conditions { get; set; }
    public List<WorkflowAction__c> actions { get; set; }

    public WorkflowRule(Workflow__c wf, List<WorkflowCondition__c> conds, List<WorkflowAction__c> acts) {
        this.workflow = wf;
        this.conditions = conds;
        this.actions = acts;
    }

    public Boolean evaluate(SObject record) {
        if (conditions.isEmpty()) return false;

        Boolean result = (workflow.Logic_Type__c == 'AND');
        for (WorkflowCondition__c cond : conditions) {
            Object fieldValue = record.get(cond.Field_API__c);
            Boolean check = WorkflowEvaluator.evaluate(fieldValue, cond.Operator__c, cond.Value__c);

            if (workflow.Logic_Type__c == 'AND') {
                result = result && check;
                if (!result) break;
            } else if (workflow.Logic_Type__c == 'OR') {
                result = result || check;
                if (result) break;
            }
        }
        return result;
    }

    public void execute(SObject record, Boolean isBefore) {
        for (WorkflowAction__c act : actions) {
            IWorkflowAction handler = ActionFactory.getAction(act.Action_Type__c);
            if (handler != null) {
                handler.execute(record, act, isBefore);
            }
        }
    }
}


---

2. Workflow Rule Builder

public class WorkflowRuleBuilder {
    public static List<WorkflowRule> buildRules(String objectName) {
        List<Workflow__c> workflows = [
            SELECT Id, Logic_Type__c
            FROM Workflow__c
            WHERE Object_API__c = :objectName AND Active__c = true
        ];

        Map<Id, List<WorkflowCondition__c>> condMap = new Map<Id, List<WorkflowCondition__c>>();
        for (WorkflowCondition__c c : [
            SELECT Id, Workflow__c, Field_API__c, Operator__c, Value__c
            FROM WorkflowCondition__c
            WHERE Workflow__c IN :workflows
        ]) {
            if (!condMap.containsKey(c.Workflow__c)) condMap.put(c.Workflow__c, new List<WorkflowCondition__c>());
            condMap.get(c.Workflow__c).add(c);
        }

        Map<Id, List<WorkflowAction__c>> actMap = new Map<Id, List<WorkflowAction__c>>();
        for (WorkflowAction__c a : [
            SELECT Id, Workflow__c, Action_Type__c, Action_Field__c, Action_Value__c,
                   Email_Template_Id__c, Task_Subject__c, Task_Status__c,
                   API_Type__c, API_Method__c, API_Payload__c
            FROM WorkflowAction__c
            WHERE Workflow__c IN :workflows
        ]) {
            if (!actMap.containsKey(a.Workflow__c)) actMap.put(a.Workflow__c, new List<WorkflowAction__c>());
            actMap.get(a.Workflow__c).add(a);
        }

        List<WorkflowRule> rules = new List<WorkflowRule>();
        for (Workflow__c wf : workflows) {
            rules.add(new WorkflowRule(
                wf,
                condMap.containsKey(wf.Id) ? condMap.get(wf.Id) : new List<WorkflowCondition__c>(),
                actMap.containsKey(wf.Id) ? actMap.get(wf.Id) : new List<WorkflowAction__c>()
            ));
        }
        return rules;
    }
}


---

3. Action Strategies

(we separate actions from conditions now)

public interface IWorkflowAction {
    void execute(SObject record, WorkflowAction__c action, Boolean isBefore);
}

public class FieldUpdateAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (isBefore) {
            record.put(action.Action_Field__c, action.Action_Value__c);
        }
    }
}

public class EmailAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (!isBefore) {
            Messaging.SingleEmailMessage mail = new Messaging.SingleEmailMessage();
            mail.setTargetObjectId(UserInfo.getUserId());
            mail.setTemplateId(action.Email_Template_Id__c);
            mail.setSaveAsActivity(false);
            Messaging.sendEmail(new Messaging.SingleEmailMessage[] { mail });
        }
    }
}

public class TaskAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (!isBefore) {
            Task t = new Task(
                WhatId = record.Id,
                Subject = action.Task_Subject__c,
                Status = action.Task_Status__c,
                OwnerId = UserInfo.getUserId()
            );
            insert t;
        }
    }
}

public class ApiAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (!isBefore) {
            if (action.API_Type__c == 'Apex') {
                WorkflowApiInvoker.invokeApex(action.API_Method__c, record);
            } else if (action.API_Type__c == 'REST') {
                WorkflowApiInvoker.invokeRest(action, record);
            }
        }
    }
}


---

4. Factory (Dependency Injection)

public class ActionFactory {
    private static Map<String, IWorkflowAction> registry;

    static {
        registry = new Map<String, IWorkflowAction>{
            'FieldUpdate' => new FieldUpdateAction(),
            'Email'       => new EmailAction(),
            'Task'        => new TaskAction(),
            'API'         => new ApiAction()
        };
    }

    public static IWorkflowAction getAction(String type) {
        return registry.get(type);
    }
}


---

5. Engine (Controller)

public class WorkflowEngine {
    public static void run(List<SObject> newRecords, Map<Id, SObject> oldMap, Boolean isBefore, Boolean isInsert) {
        if (newRecords.isEmpty()) return;
        String objectName = String.valueOf(newRecords[0].getSObjectType());

        List<WorkflowRule> rules = WorkflowRuleBuilder.buildRules(objectName);

        for (SObject record : newRecords) {
            for (WorkflowRule rule : rules) {
                if (rule.evaluate(record)) {
                    rule.execute(record, isBefore);
                }
            }
        }
    }
}


---

‚úÖ Now workflows are structured like Salesforce Workflow Rules:

One Workflow (Workflow__c) ‚Üí has multiple conditions (WorkflowCondition__c) ‚Üí and multiple actions (WorkflowAction__c).

Admins configure conditions and actions separately.

Code stays clean and extensible thanks to Builder + Strategy + DI.



---

WouldPerfect üëç you want to extend actions to support ‚ÄúSend SMS with SMS template‚Äù and ‚ÄúSend Email with Email template‚Äù (just like Salesforce Workflow Actions).

We can achieve this cleanly with our Strategy Pattern + DI setup by simply adding two new action strategies:


---

üîπ Data Model Changes

In WorkflowAction__c, add fields:

Action_Type__c (picklist ‚Üí FieldUpdate, Email, Task, API, SMS)

Email_Template_Id__c ‚Üí (for Email)

SMS_Template_Id__c ‚Üí (for SMS)

Recipient_Field__c ‚Üí (field API that holds Phone or Email, e.g., Phone on Contact)



---

üîπ New Action Strategies

EmailAction (already present, just extended for template use)

public class EmailAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (!isBefore) {
            Messaging.SingleEmailMessage mail = new Messaging.SingleEmailMessage();
            
            // recipient field from record (e.g., Contact.Email)
            String recipient = (String)record.get(action.Recipient_Field__c);
            if (String.isNotBlank(recipient)) {
                mail.setToAddresses(new String[]{recipient});
            }

            if (action.Email_Template_Id__c != null) {
                mail.setTemplateId(action.Email_Template_Id__c);
                mail.setTargetObjectId(UserInfo.getUserId()); // required for template merge
            } else {
                mail.setPlainTextBody(action.Action_Value__c);
            }

            mail.setSaveAsActivity(false);
            Messaging.sendEmail(new Messaging.SingleEmailMessage[] { mail });
        }
    }
}


---

SmsAction (new)

public class SmsAction implements IWorkflowAction {
    public void execute(SObject record, WorkflowAction__c action, Boolean isBefore) {
        if (!isBefore) {
            String phone = (String)record.get(action.Recipient_Field__c);

            if (String.isNotBlank(phone)) {
                // Retrieve SMS template
                SMS_Template__c smsTemplate = [
                    SELECT Id, Body__c
                    FROM SMS_Template__c
                    WHERE Id = :action.SMS_Template_Id__c
                    LIMIT 1
                ];

                String smsBody = smsTemplate.Body__c;

                // Example: using a custom Apex SMS service
                SmsService.sendSms(phone, smsBody);
            }
        }
    }
}


---

Example SMS Service Stub

(you can plug in Twilio, Kaleyra, Msg91, or Salesforce‚Äôs native MessagingChannel if enabled)

public class SmsService {
    public static void sendSms(String phone, String message) {
        // Example: future callout (to Twilio etc.)
        System.debug('Sending SMS to ' + phone + ' => ' + message);

        // If using a REST API integration, call Http here
        // HttpRequest req = new HttpRequest();
        // req.setEndpoint('callout:Twilio');
        // req.setMethod('POST');
        // req.setBody('To=' + phone + '&Body=' + message);
        // new Http().send(req);
    }
}


---

üîπ Factory Update

Just register SMS in the ActionFactory:

public class ActionFactory {
    private static Map<String, IWorkflowAction> registry;

    static {
        registry = new Map<String, IWorkflowAction>{
            'FieldUpdate' => new FieldUpdateAction(),
            'Email'       => new EmailAction(),
            'Task'        => new TaskAction(),
            'API'         => new ApiAction(),
            'SMS'         => new SmsAction()
        };
    }

    public static IWorkflowAction getAction(String type) {
        return registry.get(type);
    }
}


---

‚úÖ Now admins can configure a WorkflowAction__c like:

Type = Email ‚Üí pick Email Template, choose Recipient_Field__c (e.g., Email).

Type = SMS ‚Üí pick SMS Template, choose Recipient_Field__c (e.g., Phone).



---

üëâ Question:
Do you want me to make SMS Template a custom object (SMS_Template__c) like above, or should I reuse Salesforce Messaging Templates (if you are on Omni-Channel Messaging / Digital Engagement license)?






you like me to add support for grouping conditions with parentheses (like (Cond1 AND Cond2) OR Cond3) or keep it at flat AND/OR logic for now?


























