// Code Generated by Sidekick is for learning and experimentation purposes only.

/**

@description Complex Logical Expression Evaluator for Salesforce

@author Deloitte Sidekick

@date 2024

Usage: Evaluate complex logical expressions with AND, OR, and nested conditions

Example: LogicalExpressionEvaluator.evaluate('(A AND B) OR (C AND D)', variableMap)

*/

public class LogicalExpressionEvaluator {

    // Custom exception for expression evaluation errors

    public class ExpressionEvaluationException extends Exception {}

    // Operator precedence (higher number = higher precedence)

    private static final Map < String, Integer > OPERATOR_PRECEDENCE = new Map < String, Integer > {

        'OR' => 1,

        'AND' => 2

    };

    /**

    * @description Main method to evaluate a logical expression

    * @param expression String expression like "(A AND B) OR (C AND D)"

    * @param variables Map of variable names to their boolean values

    * @return Boolean result of the expression evaluation

    */

    public static Boolean evaluate(String expression, Map < String, Boolean > variables) {

        try {

            if (String.isBlank(expression)) {

                throw new ExpressionEvaluationException('Expression cannot be null or empty');

            }

            if (variables == null) {

                variables = new Map < String, Boolean > ();

            }

            // Clean and prepare the expression

            String cleanedExpr = cleanExpression(expression);

            // Substitute variables with their values

            String substitutedExpr = substituteVariables(cleanedExpr, variables);

            // Evaluate the expression

            return evaluateExpression(substitutedExpr);

        } catch (Exception e) {

            System.debug(LoggingLevel.ERROR, 'Error evaluating expression: ' + e.getMessage());

            throw new ExpressionEvaluationException('Failed to evaluate expression: ' + e.getMessage());

        }

    }

    /**

    * @description Clean and normalize the expression

    * @param expression Raw expression string

    * @return Cleaned expression string

    */

    private static String cleanExpression(String expression) {

        // Remove extra whitespace and normalize to uppercase

        String cleaned = expression.trim().toUpperCase();

        // Replace multiple spaces with single space

        cleaned = cleaned.replaceAll('\s+', ' ');

        // Ensure proper spacing around operators and parentheses

        cleaned = cleaned.replaceAll('{{{{(', ' ( ');
        cleaned = cleaned.replaceAll('\)}}}}', ' ) ');

        cleaned = cleaned.replaceAll('\s+', ' ').trim();

        return cleaned;

    }

    /**

    * @description Replace variable names with their boolean values

    * @param expression Cleaned expression string

    * @param variables Map of variable names to boolean values

    * @return Expression with variables substituted

    */

    private static String substituteVariables(String expression, Map < String, Boolean > variables) {

        String result = expression;

        // Sort variables by length (longest first) to avoid partial replacements

        List < String > sortedVars = new List < String > (variables.keySet());

        sortedVars.sort();

        // Reverse to get longest first

        List < String > reversedVars = new List < String > ();

        for (Integer i = sortedVars.size() - 1; i >= 0; i--) {

            reversedVars.add(sortedVars[i]);

        }

        for (String
            var: reversedVars) {

            String upperVar =
                var.toUpperCase();

            Boolean value = variables.get(var);

            // Replace whole words only using word boundaries

            String pattern = '\b' + Pattern.quote(upperVar) + '\b';

            result = result.replaceAll(pattern, String.valueOf(value));

        }

        return result;

    }

    /**

    * @description Recursively evaluate the logical expression

    * @param expression Expression with variables substituted

    * @return Boolean result

    */

    private static Boolean evaluateExpression(String expression) {

        expression = expression.trim();

        // Base case: if it's just a boolean value

        if (expression.equals('TRUE') || expression.equals('FALSE')) {

            return Boolean.valueOf(expression);

        }

        // Handle parentheses first (highest precedence)

        while (expression.contains('(')) {

            expression = evaluateParentheses(expression);

        }

        // Now handle AND and OR operators

        return evaluateOperators(expression);

    }

    /**

    * @description Evaluate expressions within parentheses

    * @param expression Expression containing parentheses

    * @return Expression with parentheses resolved

    */

    private static String evaluateParentheses(String expression) {

        List < String > tokens = expression.split(' ');

        Integer start = -1;

        Integer parenCount = 0;

        for (Integer i = 0; i < tokens.size(); i++) {

            if (tokens[i].equals('(')) {

                if (parenCount == 0) {

                    start = i;

                }

                parenCount++;

            } else if (tokens[i].equals(')')) {

                parenCount--;

                if (parenCount == 0 && start != -1) {

                    // Extract content between parentheses

                    List < String > innerTokens = new List < String > ();

                    for (Integer j = start + 1; j < i; j++) {

                        innerTokens.add(tokens[j]);

                    }

                    String innerExpr = String.join(innerTokens, ' ');

                    Boolean innerResult = evaluateExpression(innerExpr);

                    // Replace the parentheses group with its result

                    List < String > newTokens = new List < String > ();

                    // Add tokens before parentheses

                    for (Integer k = 0; k < start; k++) {

                        newTokens.add(tokens[k]);

                    }

                    // Add the result

                    newTokens.add(String.valueOf(innerResult).toUpperCase());

                    // Add tokens after parentheses

                    for (Integer k = i + 1; k < tokens.size(); k++) {

                        newTokens.add(tokens[k]);

                    }

                    return String.join(newTokens, ' ');

                }

            }

        }

        return expression;

    }

    /**

    * @description Evaluate AND and OR operators with proper precedence

    * @param expression Expression without parentheses

    * @return Boolean result

    */

    private static Boolean evaluateOperators(String expression) {

        List < String > tokens = expression.split(' ');

        // Remove empty tokens

        List < String > cleanTokens = new List < String > ();

        for (String token: tokens) {

            if (!String.isBlank(token)) {

                cleanTokens.add(token.trim());

            }

        }

        // Handle OR operations (lowest precedence)

        for (Integer i = 0; i < cleanTokens.size(); i++) {

            if (cleanTokens[i].equals('OR')) {

                // Split at OR and evaluate both sides

                List < String > leftTokens = new List < String > ();

                List < String > rightTokens = new List < String > ();

                for (Integer j = 0; j < i; j++) {

                    leftTokens.add(cleanTokens[j]);

                }

                for (Integer j = i + 1; j < cleanTokens.size(); j++) {

                    rightTokens.add(cleanTokens[j]);

                }

                Boolean leftResult = evaluateOperators(String.join(leftTokens, ' '));

                Boolean rightResult = evaluateOperators(String.join(rightTokens, ' '));

                return leftResult || rightResult;

            }

        }

        // Handle AND operations (higher precedence)

        for (Integer i = 0; i < cleanTokens.size(); i++) {

            if (cleanTokens[i].equals('AND')) {

                // Split at AND and evaluate both sides

                List < String > leftTokens = new List < String > ();

                List < String > rightTokens = new List < String > ();

                for (Integer j = 0; j < i; j++) {

                    leftTokens.add(cleanTokens[j]);

                }

                for (Integer j = i + 1; j < cleanTokens.size(); j++) {

                    rightTokens.add(cleanTokens[j]);

                }

                Boolean leftResult = evaluateOperators(String.join(leftTokens, ' '));

                Boolean rightResult = evaluateOperators(String.join(rightTokens, ' '));

                return leftResult && rightResult;

            }

        }

        // Base case: should be a single boolean value

        if (cleanTokens.size() == 1) {

            return Boolean.valueOf(cleanTokens[0]);

        }

        throw new ExpressionEvaluationException('Invalid expression format: ' + expression);

    }

    /**

    * @description Utility method for Salesforce-specific use cases

    * @param record SObject record to evaluate against

    * @param expression Logical expression

    * @param fieldMappings Map of variable names to field API names

    * @return Boolean result

    */

    public static Boolean evaluateRecord(SObject record, String expression, Map < String, String > fieldMappings) {

        Map < String, Boolean > variables = new Map < String, Boolean > ();

        for (String variable: fieldMappings.keySet()) {

            String fieldName = fieldMappings.get(variable);

            Object fieldValue = record.get(fieldName);

            // Convert field value to boolean

            Boolean boolValue = false;

            if (fieldValue instanceof Boolean) {

                boolValue = (Boolean) fieldValue;

            } else if (fieldValue instanceof String) {

                boolValue = String.valueOf(fieldValue).equalsIgnoreCase('true');

            } else if (fieldValue != null) {

                boolValue = true; // Non-null values are considered true

            }

            variables.put(variable, boolValue);

        }

        return evaluate(expression, variables);

    }

}





















// Code Generated by Sidekick is for learning and experimentation purposes only.
/**
 * @description Test class for LogicalExpressionEvaluator
 * @author Deloitte Sidekick
 */
@isTest
public class LogicalExpressionEvaluatorTest {
    
    @isTest
    static void testSimpleAndExpression() {
        Map<String, Boolean> variables = new Map<String, Boolean>{
            'A' => true,
            'B' => false
        };
        
        Boolean result = LogicalExpressionEvaluator.evaluate('A AND B', variables);
        System.assertEquals(false, result, 'A AND B should be false when A=true, B=false');
    }
    
    @isTest
    static void testSimpleOrExpression() {
        Map<String, Boolean> variables = new Map<String, Boolean>{
            'A' => true,
            'B' => false
        };
        
        Boolean result = LogicalExpressionEvaluator.evaluate('A OR B', variables);
        System.assertEquals(true, result, 'A OR B should be true when A=true, B=false');
    }
    
    @isTest
    static void testComplexNestedExpression() {
        Map<String, Boolean> variables = new Map<String, Boolean>{
            'isPremium' => true,
            'hasValidPayment' => true,
            'isActive' => false,
            'hasRecentActivity' => true
        };
        
        String expression = '(isPremium AND hasValidPayment) OR (isActive AND hasRecentActivity)';
        Boolean result = LogicalExpressionEvaluator.evaluate(expression, variables);
        System.assertEquals(true, result, 'Complex expression should evaluate to true');
    }
    
    @isTest
    static void testDeeplyNestedExpression() {
        Map<String, Boolean> variables = new Map<String, Boolean>{
            'A' => true,
            'B' => false,
            'C' => true,
            'D' => false,
            'E' => true,
            'F' => false
        };
        
        String expression = '((A AND B) OR C) AND (D OR (E AND F))';
        Boolean result = LogicalExpressionEvaluator.evaluate(expression, variables);
        System.assertEquals(false, result, 'Deeply nested expression should evaluate correctly');
    }
    
    @isTest
    static void testRecordEvaluation() {
        // Create a test account
        Account testAccount = new Account(
            Name = 'Test Account',
            Type = 'Customer',
            AnnualRevenue = 1000000
        );
        insert testAccount;
        
        // Reload to get all fields
        testAccount = [SELECT Id, Name, Type, AnnualRevenue FROM Account WHERE Id = :testAccount.Id];
        
        Map<String, String> fieldMappings = new Map<String, String>{
            'isCustomer' => 'Type',
            'hasRevenue' => 'AnnualRevenue'
        };
        
        // Note: This is a simplified example. In practice, you'd need custom
